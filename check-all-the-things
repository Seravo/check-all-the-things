#!/usr/bin/python3

# Copyright 2014 Jakub Wilk <jwilk@jwilk.net>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import argparse
import collections
import configparser
import fnmatch
import glob
import multiprocessing
import os
import re
import shlex
import stat
import subprocess as ipc
import sys

this = os.path.realpath(__file__)
rootdir = os.path.dirname(this)
datadir = os.path.join(rootdir, 'data')
if not os.path.isdir(datadir):
	datadir = os.path.join(os.path.dirname(rootdir), 'share', 'check-all-the-things', 'data')

def which(cmd):
    PATH = os.environ.get('PATH', '')
    PATH = PATH.split(os.pathsep)
    for dir in PATH:
        path = os.path.join(dir, cmd)
        if os.access(path, os.X_OK):
            return path

class UnmetPrereq(Exception):
    pass

class Check(object):
    def __init__(self):
        self.match = None
        self._match_fn = id
        self.cmd = None
        self.cmd_nargs = None
        self.prereq = None
        self.restrictions = []

    def set_match(self, value):
        self.match = value.split()
        regexp = '|'.join(
            fnmatch.translate(s)
            for s in self.match
        )
        regexp = r'\A(?:{re})\Z'.format(re=regexp)
        regexp = re.compile(regexp, flags=re.IGNORECASE)
        self._match_fn = regexp.match

    def set_command(self, value):
        self.cmd = cmd = value
        d = collections.defaultdict(str)
        cmd.format(**d)
        nargs = 1 * ('file' in d) + 2 * ('files' in d)
        if nargs >= 3:
            raise RuntimeError('invalid command specifiction: ' + cmd)
        self.cmd_nargs = nargs

    def set_prereq(self, value):
        self.prereq = value

    def set_restrictions(self, value):
        self.restrictions = value.split()

    def get_sh_cmd(self, njobs=1):
        kwargs = {
            'files': '{} +',
            'file': '{} \\;',
            'njobs': njobs,
        }
        cmd = self.cmd.format(**kwargs)
        if self.cmd_nargs > 0:
            fcmd = ['find -type f']
            if self.match is not None:
                if len(self.match) == 1:
                    [wildcard] = self.match
                    fcmd += ['-iname', shlex.quote(wildcard)]
                else:
                    for wildcard in self.match:
                        fcmd += ['-o', '-iname', shlex.quote(wildcard)]
                    fcmd[1] = '\\('
                    fcmd += ['\\)']
            fcmd += ['-exec', cmd]
            cmd = ' '.join(fcmd)
        return cmd

    def meet_prereq(self):
        if self.prereq is None:
            cmd = shlex.split(self.cmd)[0]
            if not which(cmd):
                raise UnmetPrereq('command not found: ' + cmd)
        else:
            try:
                with open(os.devnull, 'wb') as dev_null:
                    ipc.check_call(
                        ['sh', '-e', '-c', self.prereq],
                        stdout=dev_null,
                        stderr=dev_null,
                    )
            except ipc.CalledProcessError:
                raise UnmetPrereq('command failed: ' + self.prereq)

    def is_file_matching(self, path):
        return self._match_fn(path)

def parse_section(section):
    check = Check()
    for key, value in section.items():
        getattr(check, 'set_' + key)(value)
    return check

def parse_conf():
    checks = {}
    for path in glob.glob(os.path.join(datadir, '*')):
        cp = configparser.ConfigParser(interpolation=None)
        cp.read(path, encoding='UTF-8')
        for name in cp.sections():
            if name in checks:
                raise RuntimeError('duplicate check name: ' + name)
            section = cp[name]
            checks[name] = parse_section(section)
    return checks

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--jobs', '-j', metavar='<N>', type=int, nargs='?', default=1)
    options = ap.parse_args()
    if options.jobs is None:
        options.jobs = multiprocessing.cpu_count()
    skipped = []
    checks = parse_conf()
    matching_checks = set()
    for root, dirs, files in os.walk('.'):
        for file in files:
            path = os.path.join(root, file)
            st = os.lstat(path)
            if not stat.S_ISREG(st.st_mode):
                continue
            for name, check in checks.items():
                if name in matching_checks:
                    continue
                if check.is_file_matching(path):
                    matching_checks.add(name)
    for name, check in sorted(checks.items()):
        if not name in matching_checks:
            skipped += [(name, 'no matching files')]
            continue
        try:
            check.meet_prereq()
        except UnmetPrereq as exc:
            skipped += [(name, str(exc))]
            exc = None
        else:
            cmd = check.get_sh_cmd(njobs=options.jobs)
            print('$', cmd)
            sys.stdout.flush()
            try:
                ipc.call(cmd, shell=True, stderr=sys.stdout)
            except KeyboardInterrupt:
                skipped += [(name, 'user interrupted')]
                print()
            print()
    if skipped:
        print('Skipped checks:')
    for name, reason in skipped:
        print('- {name} ({reason})'.format(name=name, reason=reason))

if __name__ == '__main__':
    main()

# vim:ts=4 sw=4 et
